let Question : Type
    Question = [ A : Type
               ; Q : A -> Type
               ]
    Prop : Type
    Prop = Type

in
\(params : [ Ind : Type
           ; String : Type
           ; user0 : Ind
           ; agent : Ind
           ; greet : Ind -> Ind -> Type
	   ; sg    : (s:Ind) -> (a:Ind) -> greet s a
	   ; sg'   : greet agent user0
           ; ask : Ind -> Ind -> Question -> Prop
	   ; sask  : (s:Ind) -> (a:Ind) -> (q:Question) -> ask s a q
               -- a situation where s asks a question q
           ; hasName : (s:Ind) -> (name : String) -> Prop
           ; agentName : String
           ; sAgentName : hasName agent agentName
	   ; emptyMove : [ spkr    : Ind
	     	         ; addr    : Ind
			 ; content : [] ]
           ; ]) -> module


open import Lists
open import Kos params
open import Maybe
open import Booleans

open params

PolQuestion : Type
PolQuestion = [ A : Type (= Bool); Q : Bool -> Prop]

WhQuestion : Type
WhQuestion  = [ A : Type (= Ind);  Q : Ind -> Prop]

nameQuestion : Question
nameQuestion = (A = String, Q = hasName agent)

askNameMove : [ spkr : Ind
              ; addr : Ind (= agent)
              ; content : [ q : Question (= nameQuestion)
                          ; c : ask spkr addr nameQuestion]]
askNameMove = (spkr = user0
              ,addr = agent
              ,content = (q = nameQuestion,
                          c = sask user0 agent nameQuestion))

tellNameMove : [ spkr : Ind (= agent)
               ; addr : Ind
               ; content : [ answer : String
                           ; c : hasName agent agentName ]]

tellNameMove = (spkr = agent
               ,addr = user0
               ,content = (answer = agentName, c = sAgentName))

GreetingMoveContent : Ind -> Ind -> Type
GreetingMoveContent spkr addr = [c : greet spkr addr]

greetingMove : [ spkr    : Ind ; addr : Ind (= agent) ; content : GreetingMoveContent spkr addr ]
greetingMove = (spkr = user0, addr = agent, content = (c = sg user0 agent))

integrateUserMove : (c : Type)
                -> [ spkr    : Ind ; addr : Ind ; content : c]
                -> InformationState
                -> InformationState /\ [ dgb : [ latestMove : [ spkr : Ind ; addr    : Ind ; content : c]]]
integrateUserMove _ m s = (private = s.private, dgb = (latestMove = m, moves = cons Move m s.dgb.moves))

greet' : InformationState -> InformationState/\ [ dgb : [ latestMove : [ spkr : Ind ; addr    : Ind ; content : [c : greet spkr addr]]]]
greet' = integrateUserMove (GreetingMoveContent user0 agent) greetingMove

answerName : (is : InformationState /\ [ dgb : [ latestMove : [ spkr    : Ind
                                                              ; addr    : Ind (= user0)
                                                              ; content : [q : Question (= nameQuestion);
                                                                           c : ask spkr addr q]]]])
                   -> (InformationState /\
                       [ answer : [ spkr    : Ind
                                  ; addr    : Ind (= agent)
                                  ; content : [a : is.dgb.latestMove.content.q.A;
                                               c : is.dgb.latestMove.content.q.Q a]]])
answerName = \r -> (answer = _ -- tellNameMove
                   ,private = r.private
                   ,dgb = r.dgb )

ruleSet :
  [fulfilAgenda : InformationState /\ [ private : [ agenda : ReadyAgenda]] -> InformationState
  ;countergreeting : InformationState /\ [ dgb : [ latestMove : [ spkr    : Ind
                                                              ; addr    : Ind (= agent)
                                                              ; content : [c : greet spkr addr]]]]
                    -> (InformationState /\ [ private : [ agenda : ReadyAgenda ]])
  ;greeting' : InformationState  -> InformationState /\ [ dgb : [ latestMove : [ spkr    : Ind
                                                               ; addr    : Ind (= agent)
                                                               ; content : [c : greet spkr addr]]]]
  ;initialize : [] -> InformationState
  ]

ruleSet =
 (fulfilAgenda = \s -> ( private = (agenda = emptyAgenda)
                       , dgb     = (moves = cons Move (head Move s.private.agenda) s.dgb.moves
                                   , latestMove = (head Move s.private.agenda)))

 ,countergreeting = \r -> ( private = ( agenda = consAgenda ( spkr = agent
                                                        , addr = user0
                                                        , content = (c = sg'))
                                                        r.private.agenda)
                      , dgb = r.dgb )

 ,greeting' = \s -> ( private = s.private
                 , dgb     = ( moves  = s.dgb.moves
                             , latestMove = (spkr = user0, addr = agent,
                                            content = (c = sg user0 agent))))

 ,initialize = \ _ -> ( private = ( agenda = emptyAgenda)
                 , dgb     = ( moves  = emptyList Move
                             , latestMove = emptyMove)))
