let
    open import Booleans
    open import Maybe
in

module


-- Attention: recursive types MUST be defined with an *explicit*
-- split; this cannot factored out using, say, Maybe.
mutual
  List1 : Type -> Type
  List1 a = [head : a; tail : List a]

  List : Type -> Type
  List a = [ tag : Bool
           ; content : MaybeList a tag ]

  MaybeList : Type -> Bool -> Type
  MaybeList a = split
    'yes -> List1 a
    'no -> []

NonEmptyList : Type -> Type
NonEmptyList a = [ tag : True; content : List1 a ]

demoteList : (a : Type) -> NonEmptyList a -> List a
demoteList _ x = ( tag = true, content = x.content ) -- TODO: improve subtyping

emptyList : (a : Type) -> List a
emptyList a = (tag = 'no, content = ())

isNil : (a : Type) -> List a -> Bool
isNil a x = not x.tag


-- zipWith : (a b c : Type) -> (a -> b -> c) -> List a -> List b -> List c
-- zipWith a b c f = zip'
--   where
--     zip' : (aTag : Bool) -> List a -> List b -> List c
--     zip' = split
--       'no -> \_ -> 'nil ()
--       'cons x -> split
--         'nil _ -> 'nil ()
--         'cons y -> 'cons (head = f x.head y.head,
--                          tail = zip' x.tail y.tail)


foldr : (a b : Type) -> List a -> (a -> b -> b) -> b -> b
foldr a b xs f k = go (xs.tag) (xs.content)
  where go : (t : Bool) -> MaybeList a t -> b
        go = split
	   'no -> \_ -> k
           'yes -> \x -> f x.head (go x.tail.tag x.tail.content)
