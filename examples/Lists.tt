module

List : Type -> Type
List a = { nil [] | cons [head : a; tail : List a]}

zipWith : (a b c : Type) -> (a -> b -> c) -> List a -> List b -> List c
zipWith a b c f = zip'
  where
    zip' : List a -> List b -> List c
    zip' = split
      nil _ -> \_ -> 'nil ()
      cons x -> split
        nil _ -> 'nil ()
        cons y -> 'cons (head = f x.head y.head,
                         tail = zip' x.tail y.tail)


foldr : (a b : Type) -> List a -> (a -> b -> b) -> b -> b
foldr a b xs f k = go xs
  where go : List a -> b
        go = split
           nil _ -> k
           cons x -> f x.head (go x.tail)
