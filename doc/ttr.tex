% -*- latex -*-
\documentclass[11pt]{article}
\usepackage[backend=biber,citestyle=authoryear,style=alphabetic]{biblatex}

% \bibliography{PaperTools/bibtex/jp.bib}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage[dvipsnames]{xcolor}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    linkcolor={red!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}
  }
\usepackage{mathpartir}
\usepackage{fontspec}
\usepackage{unicode-math}
\usepackage[plain]{fancyref}
\def\frefsecname{Section}
\def\freffigname{Figure}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\usepackage{xargs}
\newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
\newcommandx{\info}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}}
\newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\inconsistent}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=red,#1]{#2}}
\newcommandx{\improvement}[2][1=]{\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum,#1]{#2}}
\newcommandx{\resolved}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}} % use this to mark a resolved question
\newcommandx{\thiswillnotshow}[2][1=]{\todo[disable,#1]{#2}} % will replace \resolved in the final document
% Link in bibliography interpreted as hyperlinks.
\newcommand{\HREF}[2]{\href{#1}{#2}}
\newcommand{\istype}{~\text{type}}

\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}

\author{Jean-Philippe Bernardy}
\date{\today}
\title{TTR formal system}
\newcommand\ru[1]{\text{\sc #1}}
\newcommand\Type{\mathsf{Type}}
\newcommand\splt[1]{\mathsf{split} \{ #1 \}}
\newcommand\fin[1]{\{ #1 \}}
\begin{document}

Syntax:
\begin{align*}
  t,u,A,B & ::=  x \\
          & ∣~    λx. t \\
          & ∣~    t u & \text{application} \\
          & ∣~    (\vec r) & \text{record} \\
          & ∣~    t.x & \text{projection} \\
          & ∣~    `x & \text{tag} \\
          & ∣~    \splt {`x ↦ t, …} \\
          & ∣~    \Type \\
          & ∣~    ⊥ \\
          & ∣~    (x:A) → B \\
          & ∣~    [ \vec f ] \\
          & ∣~    \fin{`\vec x }
\end{align*}

Example types:
\begin{align*}
  Σ(x:A)(B[x]) & = [fst : A ; snd : B[fst]] \\
  A × B & = Σ(\_:A)B \\
  A + B & = [choice : \fin {`a, `b}; payload : \splt {`a ↦ A; `b ↦ B}]
\end{align*}

\begin{align*}
  Γ,Δ & ::=  — \\
      & ∣  x:A, Γ
\end{align*}

Type formation rules: (we omit well-formedness of contexts for
concision).
\begin{mathpar}
  \ru{Type-form}
  \inferrule
  { }
  {Γ ⊢ \Type \istype}

  \ru{⊥-form}
  \inferrule
  { }
  {Γ ⊢ ⊥  \istype}

  \ru{→-form}
  \inferrule
  {Γ, x:A ⊢ B \istype }
  {Γ ⊢ (x:A) → B \istype}

  \ru{rec-form-l}
  \inferrule
  {Γ, x:A ⊢ [\vec f] \istype }
  {Γ ⊢ [x : A; \vec f ] \istype }

  \ru{rec-form-r}
  \inferrule
  { }
  {Γ ⊢ []  \istype }

  \ru{fin-form}
  \inferrule
  { }
  {Γ ⊢ \{`\vec x \} \istype }

  \ru{meet-form}
  \inferrule
  {Γ ⊢ A \istype \\ Γ ⊢ B \istype }
  {Γ ⊢ A ∧ B \istype}

  \ru{join-form}
  \inferrule
  {Γ ⊢ A \istype \\ Γ ⊢ B \istype }
  {Γ ⊢ A ∨ B \istype}

\end{mathpar}

Type-checking rules:
\begin{mathpar}
  \ru{→-elim}
  \inferrule
  {  Γ ⊢ t : (x:A) → B
    \\Γ ⊢ u : A}{Γ ⊢ t u : B[u/x] }

  \ru{→-intro}
  \inferrule
  {Γ, x:A ⊢ t : B }
  {Γ ⊢ λx.t : (x:A) → B }

  \ru{rec-intro-l}
  \inferrule
  { }
  {Γ ⊢ () : [ ]  }

  \ru{rec-intro-r}
  \inferrule
  {Γ ⊢ (\vec r) : [\vec f[t/x] ] \\  Γ, \vec f ⊢ t : A  }
  {Γ ⊢ (\vec r, f=t) : [\vec f, x:A ]  }

  \ru{rec-elim}
  \inferrule
  {Γ ⊢ t : [\vec f; x:A] }
  {Γ ⊢ t.x : A[t.f/f] \\ \text{(*)}  }

  \ru{fin-intro}
  \inferrule
  {  }
  {Γ ⊢ `x : \fin { `x }  }

  \ru{fin-elim}
  \inferrule
  {Γ ⊢ t_i : A[x_i]  }
  {Γ ⊢ \splt {`x_i ↦ t_i, …} : (y : \fin { `x_i, … }) → A[y] }

  \ru{meet-intro}
  \inferrule
  {Γ ⊢ t : A  \\ Γ ⊢ t : B }
  {Γ ⊢ t : A ∧ B }

  \ru{join-intro}
  \inferrule
  {Γ ⊢ t : A   }
  {Γ ⊢ t : A ∨ B }

  \ru{conv}
  \inferrule
  {Γ ⊢ t : A \\ A ⊑ B  }
  {Γ ⊢ t : B }

\end{mathpar}

(*) substitute each of the field names by the corresponding field
projection in $t$.

Subtyping judgement:
\begin{mathpar}

  \ru{sub-top}
  \inferrule
    { }
    {A ⊑ []} % [] has no elimination rule

  \ru{sub-rec-skip}
  \inferrule
    {[\vec f] ⊑ [\vec f']}
    {[x:A;\vec f] ⊑ [\vec f']}

  \ru{sub-rec-cong}
  \inferrule
    {[\vec f] ⊑ [\vec f'] \\ A ⊑ A'}
    {[x:A;\vec f] ⊑ [x:A';\vec f']}

  \ru{sub-→}
  \inferrule
    { A' ⊑ A\\B ⊑ B'}
    {(x:A) → B ⊑ (x:A') → B'}

  \ru{sub-∧-l}
  \inferrule
    {A ⊑ A'}
    {A ∧ B ⊑ A'}

  \ru{sub-∧-r}
  \inferrule
    {A ⊑ A' \\ A ⊑ B' }
    {A ⊑ A' ∧ B'}

  \ru{sub-∨-l}
  \inferrule
    {A ⊑ A' \\ B ⊑ A' }
    {A ∨ B ⊑ A'  }

  \ru{sub-∨-r}
  \inferrule
    {A ⊑ A' }
    {A ⊑ A' ∨ B'  }

  \ru{sub-fin}
  \inferrule
    {`\vec x ⊆ {`\vec x'} }
    {\fin {`\vec x} ⊑ \fin {`\vec x'} }

  \ru{sub-fin}
  \inferrule
    {`\vec x ⊆ {`\vec x'} }
    {\fin {`\vec x} ⊑ \fin {`\vec x'} }

  \ru{sub-refl}
  \inferrule
    {A = B}
    {A ⊑ B}

  \ru{sub-bot}
  \inferrule
    { }
    {⊥ ⊑ A} % ⊥ has no introduction rule

  \end{mathpar}


  The rule for application would be:
  \begin{mathpar}
  \inferrule
    {t ⊑ t' \\ u⊑u' \\ u'⊑u} 
    {t u ⊑ t' u' \\ (*)}
  \end{mathpar}

  because there can be both positive and negative occurences of the
  argument. (consider t = t' = λx. x → x). And so would be other
  eliminators. So in the end it's better to have only the reflection
  rule and drop the rules for eliminators and introductions of
  non-type rules.

  $⊑$ forms a lattice with
  $∧$ as meet,
  $∨$ as join,
  $⊥$ as least element and
  $[]$ as greatest element.

Evaluation rules:
\begin{align*}
  (λx.t) u & = t[u/x]\\
  (x = t, …).x & = t\\
  (\splt {x ↦ t, …}) `x & = t
\end{align*}

  % \ru{sub-lam}
  % \inferrule
  %   {u ⊑ t[x/y]}
  %   {λx.u ⊑ λy.t }

  % \ru{sub-rec}
  % \inferrule
  %   {x'_i = x'_j ⟶ t_i ⊑ t'_i}
  %   {(x_i = t_i) ⊑ (x'_i = t'_i) }

  % \ru{sub-split}
  % \inferrule
  %   {\fin x'_i ⊆ \fin x_i \\ x_i = x_j ⟶ t_i ⊑ t'_i}
  %   {\splt {x_i ↦ t_i} ⊑ \splt {x'_i ↦ t'_i} }

Evaluation rules for meet.
\begin{align*}
  ((x:A) → B) ∧ ((x:A') → B') &= (x:A ∨ A') → (B ∧ B') \\
  [\vec f] ∧ [\vec f']                  &= [\vec f ∧ \vec f'] \\
  ─ ∧ \vec f       &= \vec f \\
  (x:A,\vec f) ∧ \vec f'       &= x:A,(\vec f ∧ \vec f')  & x ∉ \vec f' \\
  (x:A,\vec f) ∧ (x:A',\vec f')       &= x:(A ∧ A'),(\vec f ∧ \vec f') \\
  \{ \vec t \} ∧ \{ \vec t' \} & = \{ \vec t ∩ \vec t' \} \\
  A ∧ A & = A \\
  A ∧ B & = ⊥ & \text {otherwise and if neither $A$ or $B$ is neutral.}
\end{align*}

Evaluation rules for join.
\begin{align*}
  ((x:A) → B) ∨ ((x:A') → B') &= (x:A ∧ A') → (B ∨ B') \\
  [\vec f] ∨ [\vec f']                  &= [\vec f ∨ \vec f'] \\
  ─ ∨ \vec f       &= ─ \\
  (x:A,\vec f) ∨ \vec f'       &= (\vec f ∨ \vec f')  & x ∉ \vec f' \\
  (x:A,\vec f) ∨ (x:A',\vec f')       &= x:(A ∨ A'),(\vec f ∨ \vec f') \\
  \{ \vec t \} ∨ \{ \vec t' \} & = \{ \vec t ∪ \vec t' \} \\
  A ∨ A & = A \\
  A ∨ B & = [] & \text {otherwise and if neither $A$ or $B$ is neutral.}
\end{align*}

% Perhaps have a parallel execution as the introductor of meet?
% (t|u) : A ∧ B
% (t|u) v = (t v|u v)
% (t|u).x = (t.x|u.x)
% (λx.t|λx.u) = λx.(t|u)
% (t|crash) = t

Algorithmic (bi-directional) rules (incomplete)
\begin{mathpar}
  \ru{rec-intro-l}
  \inferrule
  { }
  {Γ ⊢ (\vec f) : [ ]  }

  \ru{rec-intro-r}
  \inferrule
  {Γ ⊢ (\vec r) : [\vec f[t/x] ] \\ f=t ∈ \vec r \\ Γ ⊢ t : A  }
  {Γ ⊢ (\vec r) : [x : A; \vec f ]  }

  \ru{rec-elim}
  \inferrule
  {Γ ⊢ t : [\vec f]  \\ Γ ⊢ (t:[\vec f]).x : A}
  {Γ ⊢ t.x : A  }

  \ru{rec-elim-l}
  \inferrule
  { }
  {Γ ⊢ (t:[x:A; \vec f]).x : A  }

  \ru{rec-elim-r}
  \inferrule
  {Γ ⊢ (t:[\vec f [t.y/y]]).x : A   }
  {Γ ⊢ (t:[y:B; \vec f]).x : A  }
\end{mathpar}



% \printbibliography
\end{document}
